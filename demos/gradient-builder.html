<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAP's Gradient Builder - Interactive Demo</title>
    <meta name="description"
        content="Learn to create CSS gradients by hand - linear, radial, and conic gradients with live preview and copy-paste ready code.">
    <link rel="stylesheet" href="../css/style.css">
    <link href="../css/prism-hap-theme.css" rel="stylesheet">

</head>

<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <main id="main-content" class="gradient-builder">
        <div class="demo-header">
            <h1>üé® HAP's Gradient Builder</h1>
            <p>Create CSS gradients visually and copy the code!</p>
            <p><a href="../stations/station5.html">‚Üê Back to Station 5</a></p>
        </div>

        <!-- Tab Controls -->
        <div class="tab-controls" role="tablist">
            <button class="tab active" role="tab" aria-selected="true" aria-controls="linear-panel" id="linear-tab"
                data-type="linear">
                Linear Gradient
            </button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="radial-panel" id="radial-tab"
                data-type="radial">
                Radial Gradient
            </button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="conic-panel" id="conic-tab"
                data-type="conic">
                Conic Gradient
            </button>
        </div>

        <!-- Contrast Warning -->
        <div class="contrast-warning" id="contrast-warning" role="alert">
            <p>‚ö†Ô∏è Contrast warning: Some gradient colors may not meet WCAG AA standards (4.5:1) for text readability.
                Test with actual text before using in production.</p>
        </div>

        <!-- Preview Area -->
        <section class="preview-section">
            <h2>Live Preview</h2>
            <div class="gradient-preview" id="gradient-preview" role="img" aria-label="Live gradient preview"></div>
        </section>

        <!-- Linear Controls -->
        <div class="controls-panel" id="linear-panel" role="tabpanel" aria-labelledby="linear-tab">
            <div class="control-group">
                <label for="linear-direction">Direction (degrees)</label>
                <div class="slider-control">
                    <input type="range" id="linear-direction" min="0" max="360" value="135" step="1">
                    <output for="linear-direction" id="linear-direction-val">135¬∞</output>
                </div>
            </div>

            <div class="control-group">
                <label>Color Stops</label>
                <div class="color-stops" id="linear-stops"></div>
            </div>
        </div>

        <!-- Radial Controls -->
        <div class="controls-panel hidden" id="radial-panel" role="tabpanel" aria-labelledby="radial-tab">
            <div class="control-group">
                <label>Shape</label>
                <div class="radio-group">
                    <label for="radial-shape-circle" class="radio-label">
                        <input type="radio" name="radial-shape" id="radial-shape-circle" value="circle" checked>
                        Circle
                    </label>
                    <label for="radial-shape-ellipse" class="radio-label">
                        <input type="radio" name="radial-shape" id="radial-shape-ellipse" value="ellipse">
                        Ellipse
                    </label>
                </div>
            </div>

            <div class="control-group">
                <label for="radial-pos-x">Position X</label>
                <div class="slider-control">
                    <input type="range" id="radial-pos-x" min="0" max="100" value="50" step="1">
                    <output for="radial-pos-x" id="radial-pos-x-val">50%</output>
                </div>
            </div>

            <div class="control-group">
                <label for="radial-pos-y">Position Y</label>
                <div class="slider-control">
                    <input type="range" id="radial-pos-y" min="0" max="100" value="50" step="1">
                    <output for="radial-pos-y" id="radial-pos-y-val">50%</output>
                </div>
            </div>

            <div class="control-group">
                <label>Color Stops</label>
                <div class="color-stops" id="radial-stops"></div>
            </div>
        </div>

        <!-- Conic Controls -->
        <div class="controls-panel hidden" id="conic-panel" role="tabpanel" aria-labelledby="conic-tab">
            <div class="control-group">
                <label for="conic-angle">Starting Angle</label>
                <div class="slider-control">
                    <input type="range" id="conic-angle" min="0" max="360" value="0" step="1">
                    <output for="conic-angle" id="conic-angle-val">0¬∞</output>
                </div>
            </div>

            <div class="control-group">
                <label for="conic-pos-x">Position X</label>
                <div class="slider-control">
                    <input type="range" id="conic-pos-x" min="0" max="100" value="50" step="1">
                    <output for="conic-pos-x" id="conic-pos-x-val">50%</output>
                </div>
            </div>

            <div class="control-group">
                <label for="conic-pos-y">Position Y</label>
                <div class="slider-control">
                    <input type="range" id="conic-pos-y" min="0" max="100" value="50" step="1">
                    <output for="conic-pos-y" id="conic-pos-y-val">50%</output>
                </div>
            </div>

            <div class="control-group">
                <label>Color Stops</label>
                <div class="color-stops" id="conic-stops"></div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <button type="button" class="btn" id="add-stop-btn">+ Add Color Stop</button>
            <label for="preset-select" class="sr-only">Load gradient preset</label>
            <select class="preset-select" id="preset-select" aria-label="Load gradient preset">
                <option value="">Load Preset...</option>
                <option value="sunset">Sunset (Linear 3-stop)</option>
                <option value="ocean">Ocean (Radial 2-stop)</option>
                <option value="rainbow">Rainbow (Linear 5-stop)</option>
                <option value="spinner">Loading Spinner (Conic with transparency - add animation!)</option>
            </select>
            <button type="button" class="btn btn-secondary" id="reset-btn">Reset</button>
        </div>

        <!-- Output Section -->
        <section class="output-section">
            <h2>Generated CSS</h2>
            <pre><code id="css-output" class="language-css">background: linear-gradient(135deg, hsl(210 70% 50%), hsl(280 60% 55%));</code></pre>
            <button type="button" class="copy-button" id="copy-btn" aria-label="Copy CSS code to clipboard">Copy</button>
        </section>

        <!-- Tips Box -->
        <div class="tips-box">
            <h3>üü† HAP's Gradient Tips</h3>
            <ul>
                <li>Start with 2 colors, add more only if it improves readability</li>
                <li>Use HSL for easier color adjustments‚Äîsame hue, change lightness!</li>
                <li>Test contrast if placing text on the gradient</li>
                <li>Linear works great for headers, radial for spotlights, conic for loading spinners</li>
                <li><strong>Loading Spinner tip:</strong> The spinner preset creates a static gradient. To animate it,
                    add CSS animation as shown below!</li>
            </ul>
        </div>

        <!-- Spinner Animation Demo -->
        <section class="spinner-demo">
            <h3>üé° Loading Spinner Animation Demo</h3>
            <div class="spinner-demo-content">
                <div>
                    <div class="spinner-preview" id="spinner-preview" role="img" aria-label="Animated loading spinner">
                    </div>
                    <div class="spinner-controls">
                        <label for="spinner-speed">Animation Speed (CSS Custom Property)</label>
                        <div class="speed-control">
                            <span>Fast</span>
                            <input type="range" id="spinner-speed" min="0.5" max="3" step="0.1" value="1"
                                aria-label="Spinner animation speed in seconds">
                            <span>Slow</span>
                            <output for="spinner-speed" id="speed-value">1.0s</output>
                        </div>
                    </div>
                    <p style="text-align: center; margin-top: 1rem; font-size: 0.875rem; color: #666;">
                        This spinner uses the conic gradient from the preset + CSS animation
                    </p>
                </div>
                <div class="spinner-code">
                    <p class="spinner-code-header">CSS Best Practice: Use
                        Custom Properties!</p>
                    <code>.spinner {<br>
  <strong>--spinner-speed: <span id="code-speed-value">1.0s</span>;</strong> /* Variable */<br>
  background: conic-gradient(from 0deg,<br>
    hsl(210 70% 50%) 0%,<br>
    hsl(210 70% 50% / 0) 50%);<br>
  animation: spin <strong>var(--spinner-speed)</strong> linear infinite;<br>
}<br>
<br>
@keyframes spin {<br>
  to { transform: rotate(360deg); }<br>
}</code>
                    <p class="spinner-code-footer">
                        <strong>Why this is better:</strong> Change speed in one place (--spinner-speed) instead of
                        editing the animation line. JavaScript can update it easily too!
                    </p>
                </div>
            </div>
        </section>
    </main>

    <div id="announcement" class="sr-only" aria-live="polite" aria-atomic="true"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>

    <script>
        // State management
        const state = {
            type: 'linear',
            linear: {
                direction: 135,
                stops: [
                    { color: 'hsl(210 70% 50%)', position: 0 },
                    { color: 'hsl(280 60% 55%)', position: 100 }
                ]
            },
            radial: {
                shape: 'circle',
                posX: 50,
                posY: 50,
                stops: [
                    { color: 'hsl(210 70% 50%)', position: 0 },
                    { color: 'hsl(280 60% 55%)', position: 100 }
                ]
            },
            conic: {
                angle: 0,
                posX: 50,
                posY: 50,
                stops: [
                    { color: 'hsl(210 70% 50%)', position: 0 },
                    { color: 'hsl(350 100% 60%)', position: 100 }
                ]
            }
        };

        // Helper functions
        function hslToHex(hslString) {
            // Updated regex to accept optional alpha channel: hsl(210 70% 50%) or hsl(210 70% 50% / 0.5)
            const match = hslString.match(/hsl\((\d+)\s+(\d+)%\s+(\d+)%(?:\s*\/\s*[\d.]+)?\)/);
            if (!match) return '#000000';

            const h = parseInt(match[1]) / 360;
            const s = parseInt(match[2]) / 100;
            const l = parseInt(match[3]) / 100;

            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            const r = Math.round(hue2rgb(p, q, h + 1 / 3) * 255);
            const g = Math.round(hue2rgb(p, q, h) * 255);
            const b = Math.round(hue2rgb(p, q, h - 1 / 3) * 255);

            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        function hexToHsl(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            h = Math.round(h * 360);
            s = Math.round(s * 100);
            l = Math.round(l * 100);

            return `hsl(${h} ${s}% ${l}%)`;
        }

        // Calculate relative luminance (for WCAG contrast checking)
        function getLuminance(hslString) {
            const match = hslString.match(/hsl\((\d+)\s+(\d+)%\s+(\d+)%/);
            if (!match) return 0;

            const h = parseInt(match[1]) / 360;
            const s = parseInt(match[2]) / 100;
            const l = parseInt(match[3]) / 100;

            // Convert HSL to RGB
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            let r = hue2rgb(p, q, h + 1 / 3);
            let g = hue2rgb(p, q, h);
            let b = hue2rgb(p, q, h - 1 / 3);

            // Apply gamma correction
            r = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
            g = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
            b = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);

            // Calculate relative luminance
            return 0.2126 * r + 0.7152 * g + 0.0722 * b;
        }

        // Calculate contrast ratio between two colors
        function getContrastRatio(color1, color2) {
            const lum1 = getLuminance(color1);
            const lum2 = getLuminance(color2);
            const lighter = Math.max(lum1, lum2);
            const darker = Math.min(lum1, lum2);
            return (lighter + 0.05) / (darker + 0.05);
        }

        // Check gradient contrast (WCAG AA requires 4.5:1 for normal text)
        function checkGradientContrast() {
            const stops = state[state.type].stops;
            if (stops.length < 2) return;

            // Find lightest and darkest stops
            const luminances = stops.map(stop => ({ color: stop.color, lum: getLuminance(stop.color) }));
            luminances.sort((a, b) => a.lum - b.lum);

            const darkest = luminances[0].color;
            const lightest = luminances[luminances.length - 1].color;

            // Assume text color is dark brown (from CSS variable)
            const textColor = 'hsl(28 40% 17%)'; // Approximate --dark-brown
            const contrastWithDarkest = getContrastRatio(textColor, darkest);
            const contrastWithLightest = getContrastRatio(textColor, lightest);

            // Show warning if either end fails WCAG AA (4.5:1)
            const warning = document.getElementById('contrast-warning');
            if (contrastWithDarkest < 4.5 || contrastWithLightest < 4.5) {
                warning.classList.add('show');
            } else {
                warning.classList.remove('show');
            }
        }

        // Generate CSS
        function generateCSS() {
            const currentState = state[state.type];
            const stops = currentState.stops
                .sort((a, b) => a.position - b.position)
                .map(s => `${s.color} ${s.position}%`)
                .join(', ');

            let css;
            switch (state.type) {
                case 'linear':
                    css = `background: linear-gradient(${currentState.direction}deg, ${stops});`;
                    break;
                case 'radial':
                    css = `background: radial-gradient(${currentState.shape} at ${currentState.posX}% ${currentState.posY}%, ${stops});`;
                    break;
                case 'conic':
                    css = `background: conic-gradient(from ${currentState.angle}deg at ${currentState.posX}% ${currentState.posY}%, ${stops});`;
                    break;
            }

            return css;
        }

        // Update preview and output
        function updateGradient() {
            const css = generateCSS();
            const preview = document.getElementById('gradient-preview');
            const gradientValue = css.replace('background: ', '').replace(';', '');

            // Use setProperty with 'important' to override CSS default
            preview.style.setProperty('background', gradientValue, 'important');

            const output = document.getElementById('css-output');
            output.textContent = css;
            Prism.highlightElement(output);

            // Check contrast for accessibility
            checkGradientContrast();

            // Update button state based on stop count
            updateAddStopButton();
        }

        // Update "Add Color Stop" button state
        function updateAddStopButton() {
            const btn = document.getElementById('add-stop-btn');
            const stops = state[state.type].stops;

            if (stops.length >= 5) {
                btn.disabled = true;
                btn.textContent = 'Maximum 5 Stops Reached';
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            } else {
                btn.disabled = false;
                btn.textContent = '+ Add Color Stop';
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            }
        }

        // Render color stops
        function renderColorStops() {
            const container = document.getElementById(`${state.type}-stops`);
            const stops = state[state.type].stops;

            container.innerHTML = '';

            stops.forEach((stop, index) => {
                const stopEl = document.createElement('div');
                stopEl.className = 'color-stop';

                const hexColor = hslToHex(stop.color);
                const stopId = `${state.type}-stop-${index}`;

                stopEl.innerHTML = `
                    <div class="color-stop-header">
                        <span class="color-stop-label">Color Stop ${index + 1}</span>
                        ${stops.length > 2 ? `<button type="button" class="remove-stop" data-index="${index}" aria-label="Remove color stop ${index + 1}">Remove</button>` : ''}
                    </div>
                    <div class="color-input-group">
                        <label for="${stopId}-color" class="sr-only">Color picker for stop ${index + 1}</label>
                        <input type="color" id="${stopId}-color" value="${hexColor}" data-index="${index}" class="color-picker" aria-label="Color picker for stop ${index + 1}">
                        <label for="${stopId}-hsl" class="sr-only">HSL value for stop ${index + 1}</label>
                        <input type="text" id="${stopId}-hsl" value="${stop.color}" data-index="${index}" class="hsl-input" placeholder="hsl(210 70% 50%)" aria-label="HSL value for stop ${index + 1}">
                    </div>
                    <div class="slider-control">
                        <label for="${stopId}-position" class="sr-only">Position for stop ${index + 1}</label>
                        <input type="range" id="${stopId}-position" min="0" max="100" value="${stop.position}" step="1" data-index="${index}" class="position-slider" aria-label="Position for stop ${index + 1}">
                        <output for="${stopId}-position">${stop.position}%</output>
                    </div>
                `;

                container.appendChild(stopEl);
            });

            attachStopEventListeners();
        }

        // Attach event listeners to color stops
        function attachStopEventListeners() {
            const container = document.getElementById(`${state.type}-stops`);

            // Color pickers
            container.querySelectorAll('.color-picker').forEach(input => {
                input.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const hsl = hexToHsl(e.target.value);
                    state[state.type].stops[index].color = hsl;
                    const hslInput = container.querySelector(`.hsl-input[data-index="${index}"]`);
                    hslInput.value = hsl;
                    updateGradient();
                });
            });

            // HSL inputs - accepts modern syntax with optional alpha: hsl(210 70% 50%) or hsl(210 70% 50% / 0.5)
            container.querySelectorAll('.hsl-input').forEach(input => {
                input.addEventListener('change', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const hsl = e.target.value.trim();
                    // Updated regex: accepts hsl(h s% l%) and hsl(h s% l% / alpha)
                    if (/^hsl\(\d+\s+\d+%\s+\d+%(?:\s*\/\s*[\d.]+)?\)$/.test(hsl)) {
                        state[state.type].stops[index].color = hsl;
                        const colorPicker = container.querySelector(`.color-picker[data-index="${index}"]`);
                        colorPicker.value = hslToHex(hsl);
                        updateGradient();
                    } else {
                        e.target.value = state[state.type].stops[index].color;
                        announce('Invalid HSL format. Use: hsl(210 70% 50%) or hsl(210 70% 50% / 0.5)');
                    }
                });
            });

            // Position sliders
            container.querySelectorAll('.position-slider').forEach(input => {
                input.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const position = parseInt(e.target.value);
                    state[state.type].stops[index].position = position;
                    e.target.nextElementSibling.textContent = `${position}%`;
                    updateGradient();
                });
            });

            // Remove buttons
            container.querySelectorAll('.remove-stop').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    state[state.type].stops.splice(index, 1);
                    renderColorStops();
                    updateGradient();
                    announce('Color stop removed');
                });
            });
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const type = tab.dataset.type;

                // Update tabs
                document.querySelectorAll('.tab').forEach(t => {
                    t.classList.remove('active');
                    t.setAttribute('aria-selected', 'false');
                });
                tab.classList.add('active');
                tab.setAttribute('aria-selected', 'true');

                // Update panels
                document.querySelectorAll('.controls-panel').forEach(p => p.classList.add('hidden'));
                document.getElementById(`${type}-panel`).classList.remove('hidden');

                // Update state
                state.type = type;

                // Render and update
                renderColorStops();
                updateGradient();

                announce(`Switched to ${type} gradient`);
            });
        });

        // Control event listeners
        document.getElementById('linear-direction').addEventListener('input', (e) => {
            state.linear.direction = parseInt(e.target.value);
            document.getElementById('linear-direction-val').textContent = `${e.target.value}¬∞`;
            updateGradient();
        });

        document.querySelectorAll('input[name="radial-shape"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                state.radial.shape = e.target.value;
                updateGradient();
            });
        });

        ['radial-pos-x', 'radial-pos-y', 'conic-pos-x', 'conic-pos-y', 'conic-angle'].forEach(id => {
            const input = document.getElementById(id);
            if (input) {
                input.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    const outputEl = document.getElementById(`${id}-val`);

                    if (id.includes('pos')) {
                        const axis = id.includes('-x') ? 'posX' : 'posY';
                        const type = id.includes('radial') ? 'radial' : 'conic';
                        state[type][axis] = value;
                        outputEl.textContent = `${value}%`;
                    } else if (id === 'conic-angle') {
                        state.conic.angle = value;
                        outputEl.textContent = `${value}¬∞`;
                    }

                    updateGradient();
                });
            }
        });

        // Add color stop
        document.getElementById('add-stop-btn').addEventListener('click', () => {
            const stops = state[state.type].stops;
            if (stops.length >= 5) {
                announce('Maximum 5 color stops allowed');
                return;
            }

            const newStop = {
                color: 'hsl(0 70% 50%)',
                position: 50
            };
            stops.push(newStop);
            renderColorStops();
            updateGradient();
            announce('Color stop added');
        });

        // Presets
        const presets = {
            sunset: {
                type: 'linear',
                data: {
                    direction: 180,
                    stops: [
                        { color: 'hsl(25 100% 50%)', position: 0 },
                        { color: 'hsl(350 100% 60%)', position: 50 },
                        { color: 'hsl(280 70% 40%)', position: 100 }
                    ]
                }
            },
            ocean: {
                type: 'radial',
                data: {
                    shape: 'circle',
                    posX: 50,
                    posY: 50,
                    stops: [
                        { color: 'hsl(200 100% 70%)', position: 0 },
                        { color: 'hsl(210 80% 40%)', position: 100 }
                    ]
                }
            },
            rainbow: {
                type: 'linear',
                data: {
                    direction: 90,
                    stops: [
                        { color: 'hsl(0 100% 50%)', position: 0 },
                        { color: 'hsl(60 100% 50%)', position: 25 },
                        { color: 'hsl(120 100% 50%)', position: 50 },
                        { color: 'hsl(240 100% 50%)', position: 75 },
                        { color: 'hsl(300 100% 50%)', position: 100 }
                    ]
                }
            },
            spinner: {
                type: 'conic',
                data: {
                    angle: 0,
                    posX: 50,
                    posY: 50,
                    stops: [
                        { color: 'hsl(210 70% 50%)', position: 0 },
                        { color: 'hsl(210 70% 50% / 0)', position: 50 }
                    ]
                }
            }
        };

        document.getElementById('preset-select').addEventListener('change', (e) => {
            const presetName = e.target.value;
            if (!presetName) return;

            const preset = presets[presetName];
            state.type = preset.type;
            state[preset.type] = { ...preset.data };

            // Switch to correct tab
            document.querySelector(`.tab[data-type="${preset.type}"]`).click();

            e.target.value = '';
            announce(`${presetName} preset loaded`);
        });

        // Reset
        document.getElementById('reset-btn').addEventListener('click', () => {
            state.type = 'linear';
            state.linear = {
                direction: 135,
                stops: [
                    { color: 'hsl(210 70% 50%)', position: 0 },
                    { color: 'hsl(280 60% 55%)', position: 100 }
                ]
            };

            document.querySelector('.tab[data-type="linear"]').click();
            announce('Reset to default gradient');
        });

        // Copy button - improved UX with better failure handling
        document.getElementById('copy-btn').addEventListener('click', async () => {
            const codeElement = document.getElementById('css-output');
            const code = codeElement.textContent;
            const btn = document.getElementById('copy-btn');

            try {
                await navigator.clipboard.writeText(code);
                btn.classList.add('copied');
                btn.textContent = 'Copied ‚úÖ';
                btn.disabled = true; // Prevent rapid clicks
                announce('CSS code copied to clipboard');

                setTimeout(() => {
                    btn.classList.remove('copied');
                    btn.textContent = 'Copy';
                    btn.disabled = false;
                }, 3000); // Extended to 3 seconds
            } catch (err) {
                console.error('Copy failed:', err);
                // Auto-select the code so user can press Ctrl+C
                const range = document.createRange();
                range.selectNodeContents(codeElement);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                btn.textContent = 'Press Ctrl+C';
                announce('Copy failed. Code is now selected - press Ctrl+C to copy manually.');

                setTimeout(() => {
                    btn.textContent = 'Copy';
                    selection.removeAllRanges(); // Clear selection
                }, 4000);
            }
        });

        // Screen reader announcements
        function announce(message) {
            const el = document.getElementById('announcement');
            el.textContent = message;
        }

        // Initialize
        renderColorStops();
        updateGradient();

        // Spinner speed control - demonstrates CSS custom properties best practice
        const spinnerSpeedSlider = document.getElementById('spinner-speed');
        const speedValueOutput = document.getElementById('speed-value');
        const spinnerPreview = document.getElementById('spinner-preview');

        if (spinnerSpeedSlider && speedValueOutput && spinnerPreview) {
            spinnerSpeedSlider.addEventListener('input', (e) => {
                const speed = parseFloat(e.target.value);
                speedValueOutput.textContent = `${speed.toFixed(1)}s`;

                // Update CSS custom property - best practice!
                spinnerPreview.style.setProperty('--spinner-speed', `${speed}s`);

                // Update the code example to show current value
                const codeSpeedValue = document.getElementById('code-speed-value');
                if (codeSpeedValue) {
                    codeSpeedValue.textContent = `${speed.toFixed(1)}s`;
                }

                announce(`Spinner speed set to ${speed.toFixed(1)} seconds`);
            });
        }
    </script>

</body>

</html>